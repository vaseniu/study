Binlog和Redolog

binlog属于逻辑日志，是逻辑操作。（记录的是这个语句的原始逻辑）
innodb redo属于物理日志，是物理变更。（在某个数据页上做了什么修改）
逻辑日志有个缺点是难以并行，而物理日志可以比较好的并行操作。

1.binlog是MySQL Server层记录的日志，redo log是InnoDB存储引擎层的日志。 
  两者都是记录了某些操作的日志(不是所有)自然有些重复（但两者记录的格式不同）。
2. 选择binlog日志作为replication。

Bin log

即二进制日志,它记录了数据库上的所有改变，并以二进制的形式保存在磁盘中；
它可以用来查看数据库的变更历史、数据库增量备份和恢复、Mysql的复制（主从数据库的复制）。
语句以“事件”的形式保存，它描述数据更改。

因为有了数据更新的binlog，所以可以用于实时备份，与master/slave复制。高可用与数据恢复。

1.恢复使能够最大可能地更新数据库，因为二进制日志包含备份后进行的所有更新。
2.在主复制服务器上记录所有将发送给从服务器的语句。

Redo log

记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。
当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，
将所有数据恢复到最新的状态。

InnoDB有buffer pool（简称bp）。bp是数据库页面的缓存，对InnoDB的任何修改操作都会
首先在bp的page上进行，然后这样的页面将被标记为dirty并被放到专门的flush list上，
后续将由master thread或专门的刷脏线程阶段性的将这些页面写入磁盘（disk or ssd）。
这样的好处是避免每次写操作都操作磁盘导致大量的随机IO，阶段性的刷脏可以将多次对页面的
修改merge成一次IO操作，同时异步写入也降低了访问的时延。然而，如果在dirty page还未刷入
磁盘时，server非正常关闭，这些修改操作将会丢失，如果写入操作正在进行，甚至会由于损坏
数据文件导致数据库不可用。为了避免上述问题的发生，Innodb将所有对页面的修改操作写入一个
专门的文件，并在数据库启动时从此文件进行恢复操作，这个文件就是redo log file。这样的技术
推迟了bp页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的
写redo log操作的开销（顺序IO，当然很快），以及数据库启动时恢复操作所需的时间。

Binlog格式

1.基于SQL语句的复制(statement-based replication,SBR)， 
2.基于行的复制(row-based replication,RBR)， 
3.混合模式复制(mixed-based replication,MBR)。

Statement 
每一条会修改数据的sql都会记录在binlog中。在5.6.24中默认格式。
优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。
缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句
在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同的结果。
另外mysql的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题。

ps：相比row能节约多少性能与日志量，这个取决于应用的SQL情况，正常同一条记录修改
或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条件的update操作，
以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据
应用的实际情况，其所产生的日志量会增加多少，以及带来的IO性能问题。

Row
5.1.5版本的MySQL才开始支持row level的复制,它不记录sql语句上下文相关信息，仅保存哪条记录被修改。
优点：binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。
所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的
存储过程，或function，以及trigger的调用和触发无法被正确复制的问题.
缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量
的日志内容。

ps:新版本的MySQL中对row level模式也被做了优化，并不是所有的修改都会以row level来记录，
像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete等
修改数据的语句，那么还是会记录所有行的变更。

Mixed
从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。
在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制
的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，
也就是在Statement和Row之间选择一种。

相关参数：
innodb_flush_log_at_trx_commit = N：
N=0：每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；
N=1：每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上；
N=2：每事务提交的时候，把事务日志数据从缓存区写到日志文件中；每隔一秒，刷新一次日志文件，
     但不一定刷新到磁盘上，而是取决于操作系统的调度；

 

sync_binlog =  N：这个参数直接影响mysql的性能和完整性
N>0：每向二进制日志文件写入N条SQL或N个事务后，将执行一次fsync之类的磁盘同步指令，
     同时文件系统将Binlog文件缓存刷新到磁盘；
N=0：默认的，性能最高，风险最大。不主动刷新二进制日志文件的数据到磁盘上，而是由操作系统决定。
     当事务提交后，Mysql仅仅是将binlog_cache中的数据写入Binlog文件，但不执行fsync之类的磁盘
	 同步指令通知文件系统将缓存刷新到磁盘，而让Filesystem自行决定什么时候来做同步，这个是性
	 能最好的。

 

推荐配置组合：
N=1,1：适合数据安全性要求非常高，而且磁盘IO写能力足够支持业务，比如充值消费系统；
N=1,0：适合数据安全性要求高，磁盘IO写能力支持业务不富余，允许备库落后或无复制；
N=2,0或2,m(0<m<100)：适合数据安全性有要求，允许丢失一点事务日志，复制架构的延迟也能接受；
N=0,0：磁盘IO写能力有限，无复制或允许复制延迟稍微长点能接受，例如：日志性登记业务。





























