内存缺页错误

假如目标内存页在物理内存中没有对应的页帧或者存在但无对应权限，CPU 就无法获取数据，这种情况下CPU就会报告一个缺页错误。
由于CPU没有数据就无法进行计算，CPU罢工了用户进程也就出现了缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核
的Page Fault Handler处理。

1.Hard Page Fault
也被称为Major Page Fault，翻译为硬缺页错误/主要缺页错误，这时物理内存中没有对应的页帧，需要CPU打开磁盘设备读取到物理
内存中，再让MMU建立VA和PA的映射。
2.Soft Page Fault
也被称为Minor Page Fault，翻译为软缺页错误/次要缺页错误，这时物理内存中是存在对应页帧的，只不过可能是其他进程调入的，
发出缺页异常的进程不知道而已，此时MMU只需要建立映射即可，无需从磁盘读取写入内存，一般出现在多进程共享内存区域。
3.Invalid Page Fault
翻译为无效缺页错误，比如进程访问的内存地址越界访问，又比如对空指针解引用内核就会报segment fault错误中断进程直接挂掉。

缺页错误出现的原因
1.如使用共享内存区域，没有存储VA->PA的映射但是存在物理页帧的软缺页错误，在Page Table/TLB中建立映射关系即可。
2.访问的地址在物理内存中确实不存在，需要从磁盘/swap分区读入才能使用，这种性能影响会比较大，因为磁盘太慢了，
  尽量使用高性能的SSD来降低延时。
3.访问的地址内存非法，缺页错误会升级触发SIGSEGV信号结束进程，这种属于可以导致进程挂掉的一种缺页错误。

内存的惰性分配
1.Linux的虚拟地址空间就是空头支票，看着很大但是实际对应的物理空间只有很少的一部分。
2.内存的惰性分配是个有效的机制，可以保证内存利用率和服务器利用率，是资源合理配置的方法。
3.大量的虚拟地址到物理地址的快速准确地查询转换是一个难题。

CPU如果获取内存中的数据
1.页表存在于进程的内存之中，MMU收到虚拟地址之后查询Page Table来获取物理地址。
2.单级页表对连续内存要求高，于是引入了多级页表，但是多级页表也是一把双刃剑，在减少连续存储要求且减少存储空间的
  同时降低了查询效率。
  
MMU和TLB （Memory Manage Unit 内存管理单元 Translation Lookaside Buffer 旁路快表缓存/地址变换高速缓存）
1.CPU要根据用户进程提供的虚拟地址来获取真实数据，但是它并不自己做而是交给了MMU。
2.MMU也是个聪明的家伙，集成了TLB来存储CPU最近常用的页表项来加速寻址，TLB找不到再去全量页表寻址，可以认为TLB是MMU的缓存。
3.TLB的容量毕竟有限，为此必须依靠Page Table一起完成TLB Miss情况的查询，并且更新到TLB建立新映射关系。
