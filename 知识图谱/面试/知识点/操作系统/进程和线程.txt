进程和线程

进程
PCB（progress control block），进程控制块。
内核空间中通过链表管理所有进程的PCB。

PBC task_struct包含的信息：
1.标识相关：pid，ppid等等；
2.文件相关：进程需要记录打开的文件信息，于是需要文件描述符表；
3.内存相关：内存指针，指向进程的虚拟地址空间（用户空间）信息；
4.优先级相关：进程相对于其他进程的调度优先级；
5.上下文信息相关：CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到
  另一个进程时，需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，
  能够恢复切换时的状态，继续执行；
6.状态相关：进程当前的状态，说明该进程处于什么状态；
7.信号相关：进程的信号处理函数，以及记录当前进程是否还有待处理的信号；
8.I/O相关：记录进程与各种I/O设备之间的交互。

对于一个进程，它在被执行前其实是一个可执行程序。这个程序是被放在磁盘上的，当它要被执行的时候，
它先被加载到内存当中，然后再放入到寄存器中，最后再让cpu执行该程序，这个时候一个静态的程序就变成了
进程。

进程的内存分配
每个进程运行的时候，都会拿到4G的虚拟内存，在32位Linux下，其中3G是交给用户的，1G是交给内核的，
而task_struct就是存储在这1G的内核系统空间中。

每个进程都有各自的私有用户空间（0-3G），这个空间对系统中的其他进程是不可见的。
最高的1GB内核空间则为所有进程以及内核所共享。
至于为什么需要这个1G的内核空间，是因为进程需要调用一些系统调用，来交给内核跑，程序的一部分
逻辑可能是要交给内核去跑的，所以一部分虚拟地址必须要留给内核使用。

进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成
多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。

线程
线程共享内容：
1.进程代码段；
2.进程的共有数据（利用这些共享数据，线程很容易的实现相互之间的通讯）；
3.进程打开的文件描述符；
4.信号的处理器；
5.进程的当前目录；
6.进程用户ID与进程组ID。


线程独有的内容：
1.线程ID；
  每个线程都有自己的线程ID，这个ID在本进程中一唯一的，进程用此来标识线程。
2.寄存器组的值；
  由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到啊另一个线程上时，
  必须将原有的线程的寄存器集合的状态保存，以便将来改线程在被重新切换到时能得以恢复。
3.线程的栈；
  堆栈是保证线程独立运行所必须的，线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，
  使得函数调用可以正常执行，不受其他线程的影响。
4.错误返回码；
  由于同一个进程中有很多歌线程 在同时运行，可能某个线程进行系统调用后设置了error值，而在该线程还没有处理这个错误，另外一个
  线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。
5.线程的信号屏蔽码；
  由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理，但所有的线程都共享同样的信号处理器。
6.线程的优先级：
  由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是好线程的优先级。
 

